---
title: "자동차 경주게임 만들기"
excerpt: "java 공부"
permalink: /study/3

categories:
  - study
tags:
  - study

last_modified_at: 2020-06-23
---

# 자동차 경주게임 

<br>

## TDD 란
요구사항에 맞추어 TEST 코드를 구현하고, 테스트가 성공하도록 실제 프로덕션 코드를구현하는 것이다!  
**단위 테스트를 작성하고 production code를 작성한다.**  
<br>

## 자동차 경주 게임 요구사항
- 사용자는 이름을 쉼표 기준으로 구분해 입력
- 이름은 5자 이내
- 사용자는 몇 번의 이동을 할 것인지 입력
- 주어진 횟수 동안 n대의 자동차는 전진 또는 멈춤
- 전진은 각 자동차 0-9의 random 값이 4이상이면 전진, 3이하면 멈춤
- 전진하는 자동차 출력할 때 이름도 같이 출력
- 우승자 출력
- 공동 우승이면 우승자 모두 출력
<br>

## 새로 배운 함수
1. 스트림
  - stream은 컬렉션, 배열 등의 저장 요소를 하나씩 참조하며 함수형 인터페이스를 적용하며 반복적으로 처리할 수 있도록 해주는 기능  
  - stream.collectors.tolist 에 있는 .collect(toList())는 list로 모아준다.  
  - boxed는 stream을 매핑해준다.  
2. int 와 Integer의 차이  
  - int는 내가 흔히 아는 long, float, double 등과 같은 정수 자료형이고 산술 연산이 가능하며 null로는 초기화할 수 없는 wrapping 된 정수이다.  
  - Integer는 wrapper 클래스로 객체이며, unboxing하지 않으면 연산이 불가능하지만 null은 처리할 수 있다.  
  - Integer.valueOf(String)은 클래스로 리턴되어 계산이 안되지만 Integer.parseInt(String)은 자료형으로 계산 가능하다.  
3. 단위 테스트를 하는 경우
  - 로직이 필요하다면 단위 테스트를 해야하지만 이미 만들어진 라이브러리로 할 경우 필요없다..  
4. 배열 테스트 하기
  - String[]의 경우 = {"abc", "de"}로 actual, expected 나눠서 확인  
  - List<>의 경우 = Arrays.asList("abc", "de")로 actual, expected 나눠서 확인  
<br>

### 코드 관련 새로 배운 것

1. 객체와 인스턴스  
    - 클래스의 인스턴스가 객체이다. 클래스가 추상화된 것이라면, 인스턴스는 실제로 그것을 사용하기 위하여 실체화해 만들어내는 것이다.  
    - 객체를 설계하면서 이 필드 변수가 꼭 이 객체에 속해 있어야 하는지 항상 생각해야한다.  
    - 인스턴스 메소드는 인스턴스의 상태를 변경할 때 사용한다. 인스턴스 생성 후 메소드 호출 가능하다. 인스턴스 필드는 상태 정보를 갖고 있는 변수.  
    - 클래스 메소드는 인스턴스와 무관하다. 클래스 필드는 인스턴스에서 공유하는 정보가 있는 경우 사용한다.  
    - 붕어빵틀(클래스)과 붕어빵(객체) 그자체 생각!!  
    - 어디서 객체를 생성하고 그 객체의 메서드를 사용하는지, 어디서 클래스로 메서드를 사용해야하는지 생각하여 생성해야 한다.  
2. static  
    - **클래스 메소드와 클래스 필드**를 지정할 때 사용한다.  
    - 전역 변수로 함수 쓸때 static 붙이고,  
    - static 내에서만 static 호출  
    - 전역 함수로 사용할 때만 static ; 클래스의 메서드로 사용할 때만 이렇게 쓴다!  
    - 변수에 static을 사용할 경우 변치 않는 값이 된다. 매직넘버처럼!! 변수가 클래스의 변수가 될지, 객체의 변수가 될지 생각하고 사용해야 한다.  
3. 생성자  
    - 객체 생성을 위해 호출하는 메소드  
    - 여러개의 생성자를 이용해 원하는 일을 수행하게 할 수 있다.  
4. 변수명  
    - 불용어(프로그래밍 시 사용하는 언어)를 사용하지 않고 정확한 의미를 가지게 붙이자.  
5. 객체 지향  
    - 클래스는 표현 대상의 특징에 대한 서술  
    - 객체는 클래스의 인스턴스  
    - 캡슐화 상속성 다형성  
6. 원시타입과 참조타입  
    - Integer, Short, String, Boolean이 원시타입  
    - int, short, boolean이 참조타입  
    - 값을 쓸때만 참조  
7. getter의 사용  
    - getter는 출력일 때만 사용  
    - getter 보다는 객체에 메시지를 보내도록 구현 (ex: position아 너 이거랑 같니? 이렇게)  
8. final은 언제 사용할 것인가  
    - final은 불변객체 **다시 공부할 것**  
9. 객체로 감싸서 얻는 이점(유효성 검사 등)이 있는 경우 웬만하면 감싼다.  
    - 유효성 검사를 분산시켜주는 것이 큰 이점  
10. asasertThat.extracting()사용하면 값 추출 가능  
11. 생성자에서 this(또다른 생성자); 사용 할것  
    - 생성자는 많을수록 좋다.  
    - 코드 중복 제거에 좋다.  
12. 정적팩토리메서드 **다시 공부할 것**  
    - List<Car> cars를 가진 Cars 객체 생성  
    - null exception : Objects.requireNonNull(cars, message:"A");  
    - null값 예외처리 중요함  
13. 인터페이스  
    - generate()를 구현하는 RandomNumber..  
    - 인터페이스는 다형성,, 다양한 기능 구현할 수 있다. **다시 공부할 것**  
14. stream  
    - stream에서 .collect(collectingAndThen(toList()), Cars::new) 하면 리스트로 나눠서 또 뭘 하겠느냐  
15. orElse(), orElseThrow()
    - get(...)과 orElse(...)는 모두 ...에 값이 있든지 없든지 생성된다!!
    - 따라서 orElseThrow(()->new NoSuchElementException())을 사용하는 것이 null에서 예외를 발생시키기에 합당함
    - 예외 클래스를 만들어서 던져주어야 한다.