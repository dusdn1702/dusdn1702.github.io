--
title: "운영체제와 정보기술의 원리"
excerpt: 5장
permalink: /study/55
categories:
  - techcourse
  - os
tags:
  - techcourse
  - os 

last_modified_at: 2021-08-03
---  
# 5장 프로세스 관리

## 1. 프로세스 개념

실행 중인 프로그램

디스크에 실행파일로 존재하던 프로그램이 메모리에 올라가 실행되기 시작하면 프로세스가 된다.

프로세스는 CPU를 얻어 자신의 코드를 수행하기도 하고 자신의 임무를 다 수행하면 종료되어 사라진다. 

- 프로세스 문맥(context)

  프로세스가 현재 어떤 상태에서 수행되고 있는지 알기 위해 필요한 정보

  각 프로세스들이 CPU를 빼앗겼다가 다시 돌아와서 수행하는 것을 반복하기 때문에 중요하다.

  - 하드웨어 문맥

    CPU의 수행 상태 (PC 값, 각종 레지스터 값)

  - 프로세스의 주소공간

    코드, 데이터, 스택으로 구성되는 독자적인 주소 공간

  - 커널 상의 문맥

    시스템 콜 등을 통해 커널에서 수행한 일의 상태

    프로세스에 관해 커널이 관리하고 있는 정보로 프로세스를 관리하기 위한 자료구조 (PCB, 커널스택)

<br>

## 2. 프로세스의 상태

- 시작

  프로세스가 시작돼 자료구조는 생성되었지만 메모리 획득 승인을 못받은 상태

- 실행

  프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태(매 시점 하나)

- 준비

  프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 할당받지 못한 상태

- 봉쇄

  CPU를 할당받더라도 당장 실행할 수 없는 상태 (ex 프로세스가 요청한 입출력 작업이 진행 중)

- 완료

  프로세스가 종료됐지만 자료구조를 완전히 정리하지 못한 상태

### 문맥교환

실행시킬 프로세스를 변경하기 위해 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 것

Ex) 타이머 인터럽트, 입출력 요청으로 봉쇄 되는 경우

- CPU 디스패치

  준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 것

<br>

## 3. 프로세스 제어블록(PCB)

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조

- 프로세스 상태(process state)

  CPU를 할당해도 되는지 여부 결정을 위해 필요

- 프로그램 카운터(pc) 값

  다음에 수행할 명령의 위치

- CPU 레지스터 값

  CPU 연산을 위해 현 시점에 레지스터에 저장하고 있는 값

- CPU 스케줄링 정보

  프로세스 CPU 스케줄링

- 메모리 관리 정보

  프로세스 메모리 할당

- 자원 사용 정보

  자원 사용 요금 청구

- 입출력 상태 정보

  프로세스가 오픈한 파일 정보 등

<br>

## 4. 문맥교환(context switch)

하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU 제어권 넘어가는 것

- 타이머 인터럽트 발생 시

  실행 중 프로세스 문맥 저장, 실행 중 프로세스 준비 상태, 할당받은 프로세스 실행 상태, 실행 중 프로세스 문맥 저장, 할당받은 프로세스 문맥 복원

- 프로세스가 입출력 조건 충족을 못해 CPU를 회수당하고 봉쇄 상태 되는 경우

두 경우 외에는 문맥교환이 일어나지 않고 실행 모드만 바뀐다. 사용자모드<->커널모드

왜냐하면 문맥교환에 소요되는 시간은 오버헤드일 수 있기 때문에 적절한 CPU 할당시간이 중요하다.

<br>

## 5. 프로세스를 스케줄링하기 위한 큐

- 준비큐

  운영체제는 프로세스들을 줄 세워두고 앞에서부터 CPU를 할당한다.

  CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합

- 장비 큐

  특정 자원을 기다리는 프로세스들 줄 세우기 (ex 입출력 큐)

- 작업 큐

  시스템 내의 모든 프로세스 관리하기 위한 큐

  준비/봉쇄 상태에 잇는 프로세스도 포함

소프트웨어 자원은 공유 데이터인데 훼손되면 안되므로 일관성을 위해 매 시점 하나의 프로세스만 접근하도록 해야 한다. 

공유 데이터에 접근 중인 프로세스가 준비/봉쇄 상태가 되었어도 허용되지 않는다.

프로세스가 다 사용하고 반납할 때까지 접근 불가해야 한다.

커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 프로세스의 상태를 관리하므로써 각 큐의 관리를 커널에 맡기게 된다.

큐는 **각 프로세스의 PCB를 연결 리스트 형태**로 관리하며 **포인터**를 사용해 순서를 정한다.

<br>

## 6. 스케줄러

어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드

- 장기 스케줄러

  작업 스케줄러로 어떤 프로세스를 준비 큐에 진입시킬지 결정

  메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.

  현대의 시분할 시스템에서 사용되는 운영체제에는 잘 두지 않는다. 

  가끔 호출되어 느려도 된다.

- 단기 스케줄러

  CPU 스케줄러로 준비 큐에서 어떤 프로세스 할당할지 결정

  밀리 초 단위로 호출되어 속도가 빠르다.

  ex) 타이머 인터럽트

- 중기 스케줄러

  너무 많은 프로세스에게 메모리를 할당해 성능이 저하되지 않기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절

  프로세스 중 일부의 메모리(봉쇄 상태 -> 준비 큐로 이동하는 애)를 통째로 빼앗아(스왑 아웃) 그 내용을 디스크의 스왑 영역에 저장

  - 프로세스의 상태: **중지**

    중지되어 메모리 자원이 당장 필요하지 않은 것으로 디스크로 스왑 아웃된 프로세스이다.

    - 중지준비

      준비 상태에 있던 프로세스가 스왑 아웃된 상태

    - 중지봉쇄

      봉쇄 상태에 있던 프로세스가 스왑 아웃된 상태, 봉쇄되었던 조건 만족시 중지준비로 전환

<br>

## 7. 프로세스의 생성

시스템 부팅 후 최초 프로세스는 운영체제가 생성하지만 그 후로는 복제 생성한다.

부모 프로세스가 종료될 경우에는 자신이 만든 자식 프로세스를 종료시켜야 한다.

프로세스 자원도 부모와 공유하거나 운영체제로부터 받을 수 있다.

프로세스 수행 모델도 부모 자식이 공존하는 모델과 자식이 종료될 때까지 부모가 기다리는 모델이 있다.

부모 자식이 공존하면 경쟁을 통해 CPU를 얻어야 하고 자식이 얻어내어 생성하는 주소 공간도 부모의 주소 공간을 복사한다.

자식은 부모와 문맥까지 복제해 PC 지점도 일치한다. 운영체제는 식별자(fork()의 결괏값 0)를 통해 구분한다.

종료되는 과정도 자발적 종료와 부모가 강제로 자식을 종료하는 비자발적 종료가 있다.

Fork() 후 exec()을 통해 새로운 프로그램을 수행할 수 있다. 둘 다 특권명령이다.

부모를 봉쇄 상태로 만드는 wait()을 통해 프로세스 간 동기화가 이뤄진다.

<br>

## 8. 프로세스 간의 협력

프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다. 업무의 효율성도 좋고, 처리 속도와 같은 면에서 효율적일 수 있다. 

### IPC

운영체제는 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신과 동기화를 이루기 위한 메커니즘인 IPC를 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미치도록 한다. 

- 메시지 전달 방식

  프로세스 간 공유 데이터를 사용하지 않고 메시지를 주고받으면서 통신하는 방식, 주소 공간이 달라 커널을 통해야 한다.

  두 프로세스는 커뮤니케이션 링크를 생성하고 send, receive를 이용해 메시지를 주고받는다.

  - 직접통신

    메시지 전송 대상이 다른 프로젝트

    Send(P, message)와 같이 P라는 프로세스 이름을 명시적으로 표현

  - 간접통신

    메일박스나 포트라는 저장공간으로부터 메시지를 주고받는다.

    고유의 id를 가진 메일박스를 공유하는 경우에만 커뮤니케이션 링크가 생겨 통신할 수 있다.

    Send(A, message)와 같이 A라는 메일박스에 메일을 보낸다. 각 프로세스에게 다른 링크를 주거나, 시스템이 아무나 받아서 알려줘~ 라고 할 수 있다.

- 공유메모리 방식

  프로세스들이 주소 공간의 일부를 공유해 서로 다른 프로세스들이 각자의 주소 공간 중 일부를 공유할 수 있도록 한다.

  프로세스 간의 통신을 수월하게 만드는 인터페이스를 제공한다. 일관성 문제에 대해서는 프로세스끼리 해결해야 한다.