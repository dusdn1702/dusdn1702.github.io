---
title: "[우아한테크코스] 4월 24일 TIL"
excerpt: "오늘의 배운 점 정리"
permalink: /techcourse/57

categories:
  - techcourse
  - java
tags:
  - techcourse  
  - java
---  
## [Spring] layered architecture
1. presentation 계층  
사용자와 맞닿아있는 계층으로 사용자가 이용할 수 있는 기능들이 존재하고 요청을 보낼 수 있어야 한다.
ex) template, js 계층  
2. 제어 계층  
presentation 계층과 비즈니스 로직 계층을 분리하기 위한 controller  
사용자 요청을 검증하고 적절한 응답을 전달  
ex) controller
3. 비즈니스 로직 계층  
핵심 업무 로직, 데이터 적합성 검증, presentation, persistance 계층을 연결하기 위함  
ex) service  
4. 퍼시스턴스 계층  
데이터 처리 담당 계층, crud db 처리  
ex) repository
5. 도메인 계층  
실질적인 객체  
ex) dto
컨트롤러는 view와 domain을 연결시켜주는, 사용자의 입력에 따른 수행을 각 객체에게 하라고 전달하는 계층이라고 생각한다. 웹 콘솔에서는 들어온 입력에 대한 로직을 각 객체가 수행하도록 컨트롤러가 명령했다. 하지만 스프링에서의 controller는 사용자가 어떠한 요청을 했을 때 그에 대한 응답을 웹에 뿌려줄 필요가 있다.  
그렇다면 콘솔의 controller가 그러했듯 핵심 로직을 수행할 클래스는 무엇일까?  
그게 바로 service이다. service에서는 db에 저장되어 있는 데이터들을 로직에 따라 수행하도록 repository에 명령하고, 얻어낸 데이터를 조작해 필요한 값을 얻어내고자 한다.  

도메인 객체들이 각각이 수행해야할 임무가 존재한다. 수행한 임무에 따라서 database에 무엇인가 전달해야할 결과가 나온다.  
db와 도메인 객체를 연결해주며 프로그램의 핵심적인 로직을 수행하는 것이 service라고 생각한다.

## [Spring] singleton
java에서는 여러 명의 유저가 동시에 서버에 접속해서 자원을 사용한다면, 각 스레드 당 객체들이 생성된다. 따라서 스레디의 개수만큼 객체가 생성된다.  
객체의 메모리가 서버의 힙 메모리 공간에 저장된다.  
spring에서는 각 스레드마다 새로운 객체를 만들지 않고 bean으로 선언된 자원을 각 스레드가 공유한다.  
이렇게 함으로써 서버의 힙 공간에는 초기 세팅 시에 하나의 객체만 생성된다.  
Java static의 공유 범위는 Classloader.
Spring singleton의 공유 범위는 ApplicationContext.(Spring IoC Container 안에서 하나만 생성됨)  
tomcat은 각 web application(war)마다 classloader를 따로 사용  
서로 다른 war에 속한 클래스들은 서로 참조할 수 없다.  
상위 classloader의 클래스는 하위에서 참조 가능하다. 동일 class를 사용하더라도 static 변수는 공유하지 않는다. common에 static으로 선언되어야 같은 인스턴스를 참조한다.  
spring에서도 서로 다른 servlet context 간에는 참조가 불가능하다.  
이 경우에 static 선언이 되어있다면 동일한 인스턴스를 참조한다.  

## [SQL] connection pool  
connection 생성과 삭제에 발생하는 오버헤드를 방지하기 위해 connection 객체를 일정량 모아둔 pool을 생성해두고 재활용하는 방식  
javax.sql.DataSource 객체가 동시에 생성되어 커넥션 풀 관리  
- close를 실행하지 않으면 생기는 문제?  
statement를 닫지 않으면 statement 개수가 증가해 더 이상 생성할 수 없게 된다.  
불필요한 자원(네트워크, 메모리) 낭비  
connection을 닫지 않으면 새로운 connection 생성 불가(커넥션풀을 사용하면 해결 가능)  

## [Spring] bean?  
spring bean은 pojo(plain, old java objects)  
애플리케이션의 핵심으로 spring IoC 컨테이너에 의해 인스턴스화, 관리, 생성  
bean의 정의  
- class: java 클래스명  
- id: bean의 고유 식별자  
- scope: 객체의 범위(singletone, prototype)  
- constructor-arg: 생성 시 생성자에 전달할 인수  
- property: 생성 시 bean setter에 전달할 인수  
- init/destroy 메서드  

## [Spring] @ComponentScan  
어노테이션이 부여된 class를 bean으로 등록  
- basePackages로 직접 패키지경로를 적어 스캔 위치 지정  
- basePackageClasses로 class가 위치한 곳이 스캔할 위치  

## [Java] 다중상속  
java는 다중 상속을 지원하지 않는다.  
그 이유는 서로 같은 메서드 시그니처를 가진 두 클래스를 상속하는 경우 어떤 클래스를 실행해야하는지 알 수 없기 때문이다.  
하지만 인터페이스의 경우에는 상속받은 자식 클래스가 그 같은 메서드 시그니처를 이용해 구현체를 구현을 하기 때문에 다중상속이 허용되는 것이다.  

### 샐리 질문
자기 소개우아한테크코스를 지원한 이유?
미션을 하면서 TDD 방식으로 미션을 진행 하셨는데, TDD를 하면서 느낀 점과 장점과 단점
제가 이해한 것은 테스트 코드를 작성하고 프로덕션 코드를 작성하는 것으로 이해했는데 어떻게 테스트 코드가 비어있는지?
null을 반환하는 것 대신 Optional을 사용하면 어떤 장점이 있나요?
Optional의 비용이 커서 다시 null로 바꾸었다고 했는데, Optional 대신 null을 반환하는게 나은가요?
Optional이 비용이 비싸다는데 왜 비싼가요?
배열보다 제공되는 프레임워크를 쓰려고 하는 이유?
Enum으로 관리했을 때 어떤 점이 좋았나요?
캡슐화를 위해 방어적 복사를 사용했다고 하셨는데, 캡슐화와 방어적 복사 사이의 관계가 무엇인가요?
불변 객체가 아닌 것은 캡슐화가 깨져있는 객체인가요?
불변 객체의 장점이 무엇일까요?
원시값을 포장하고 일급 컬렉션을 만들면 어떻게 객체 지향이 지켜질까요?
uncheckedException과 checkedException의 차이?
최근 언어들을 보면 checkedException은 없애고 uncheckedException으로 많이 관리하려고 하는데 왜 그런가요?
상태 패턴의 특징과 장점은?
상속과 조합의 차이상속을 사용하면 부모와 자식이 동일한가요?
정적 팩토리 메서드를 사용하면 어떤 장점이 있을까요?
JDBC에서 커넥션 자원들을 close하지 않으면 어떤 문제가 발생하나요?-> memory가 부족하다는 답변
Memory영역은 애플리케이션 영역을 말씀하시는 것인가요?
그렇다면 close 안했을 때 DB에 부하가 가지 않겠네요?
도메인 대신 DTO를 넘기면서 경험했던 장점은?도메인 객체는 왜 (view에서) 건들이면 안될까요?
서비스 계층의 정의가 무엇일까요?
컨트롤러의 계층의 역할은 무엇인가요?
이전 미션에서 서비스가 나오지 않았던 이유?
서비스는 도메인인가요?
서비스가 비즈니스 로직을 다룬다고 했고, 도메인에서 비즈니스 로직을 다룬다고 했는데 그렇다면 도메인은 서비스가 아닌가요?

### 모의면접 피드백
- 두괄식으로 답변을 하는 연습을 하는것이 중요해보인다.
- 발음도 좋고, 좋은 답변인데, 정리가 되어있지 않는 느낌이다.
- 면접관이 모른다는 생각을 해볼만 하다.
- 어.. 라는 접두어 조심!
- 모르는 것은 모른다고 얘기하는 모습이 멋짐
- 생각을 해보고 정리를 하는 모습이 좋음!!
- 정성스럽게 잘해주셨다.
- 대부분 이렇게 알고있고, 이렇게 한다라고 해서 좋았다.
- 준비를 많이 하신거 같고, 주관이 있어서 좋았던거같다.
- 모르는건 모른다고 시원하게 말하는게 좋을듯해서.
- 재밌었다.
- 잘모르더라도 생각하면서 고민하면서 답변하는 모습이 좋았다.
- 대화하듯이 답변을 하려하는것이 좋았다.
- 현재의 생각이 더 낫다 생각했을 때 현재는 바꼈다라는 생각했다.
- 질문을 이어가는경우는 재밌었던 경우, 원하는 대답을 못들었던 경우. 면접관이 어떤 의도인지 생각해보고 답변하는 것도 좋아보인다."
