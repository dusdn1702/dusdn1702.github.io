---
title: "[우아한테크코스] 2월 26일 TIL"
excerpt: "오늘의 배운 점 정리"
permalink: /techcourse/20

categories:
  - techcourse
  - java
tags:
  - techcourse
  - java
---  
## 오늘 배운 점 정리  
1. 로또 피드백 강의  
2. 모던 자바 인 액션 스터디  
2. 로또 피드백 반영 리팩토링  
3. outputview, inputview 수정해보기 - 연습으로 다시 lotto 구현 (주말)
4. 객체 구조 그려보기 

### 로또 피드백 강의
**한번에 한 가지씩 집중해서 습관을 만들어 나가자**  
*내 생각과 주관을 가지고 가자*  
- 객체 설계를 어떻게 할지 모르겠다면 시작은 클래스 메서드 구현으로 시작한 후 지속적인 리팩토링  
- getter/setter의 사용을 최소화하자  
- 불변의 객체를 활용하자  
- 상속 관계에서 함수 재정의는 `오버라이딩`  
- 그냥 함수 재정의는 `오버로딩`  
- 작은 단위로 안전하게 리팩토링할 때 일단 새로운 변수를 만들어서 컴파일을 통과하고 다음 리팩토링을 점차 진행하도록 한다.  
- set으로 LottoTicket 구현하는 것도 고려  
- 인스턴스 할당과 유효성 검증 `주생성자`  
- 타입 변환 `부생성자`  

- 캐싱을 Map으로 할지, 배열로 할지 생각해보기  
- isSameAs() 사용하면 같은 인스턴스인지 검증 가능  

### 모던 자바 인 액션 스터디  
#### 2장 - 동작 파라미터화  
- 전략패턴은 함수형 인터페이스를 적용한 패턴이고 함수형 인터페이스는 동작 파라미터화를 이용한 것이다 는 아니구 전략패턴의 무수한 예시 중에 함수형 인터페이스가 있는 것이다. 함수형 인터페이스는 추상화 메서드가 단 하나만 있어야 함  
- 객체 지향 프로그래밍인 자바가 아닌 함수형 프로그래밍을 사용하는 몇 언어에서는 함수 자체를 객체로 확인할 수 있다.[함수형 프로그래밍](https://www.youtube.com/watch?v=jVG5jvOzu9Y&list=PLpO7kx5DnyIExYt0jkyWWjx8XNA2Fx2rI&index=9)  

#### 3장 - 람다 표현식  
- 함수형 인터페이스 사용시 함수를 오버로딩할 경우 캐스팅이 필요하다  
- 기본자료형 인터페이스의 사용이 더 장려된다.  
- 안쓰면은 자동을 close 해주는 try-with-resource 해주는 `실행-어라운드 패턴`  
InputStream, OutputStream, java.sql.Connection 같은 자원들은 **close** 메서드가 필수이다. 이런 애들은  
```java
BufferedReader br = new BufferedReader(new FileReader());
try {
    return br.readLine();
} finally {
    br.close();
}
```  
와 같이 자원을 닫아주는 메서드인 close의 호출이 필요하다.  
자바 7부터 AutoCloseable 인터페이스를 구현한 자원을 사용하면 `try-with-resources`를 사용할 수 있다.  
이를 사용하면 catch 절을 사용할 수 있어 여러 예외를 처리할 수도 잇고, 알아서 close도 해준다.  

- 인터페이스: 다중 상속이 가능하다  
- 함수형 인터페이스를 기대하는 곳에서만 람다 표현식을 사용할 수 있다. 언어가 복잡해지기 때문이다.
대부분의 자바 프로그래머가 하나의 추상 메서드를 갖는 인터페이스에 익숙해서라고 한다.  
+ 추상클래스 vs default 메서드를 사용할 수 있는 인터페이스  
추상클래스: abstract라는 키워드와 함께 선언된 클래스  
추상메서드: 구현부가 없는 메서드  
둘은 인스턴스화가 불가능하고, 구현부가 있는 메서드와 없는 메서드 모두 가질 수 있다.  
추상클래스에서는 static final 필드 지정이 가능하고 모든 접근 지정자도 사용 가능하다. 상속을 통해 구현된다. 상속받은 클래스는 다른 클래스 다중 상속이 안된다.  
인터페이스는 기본적으로 public static final을 사용한다. 다른 여러 인터페이스를 함께 구현할 수 있다.   
[참고](https://yaboong.github.io/java/2018/09/25/interface-vs-abstract-in-java8/)  
    - 추상클래스 
        여러개의 가까운 클래스들 (is-a 관계가 형성될) 사이에 동일한 코드를 공유해서 사용하고 싶을때.  
        추상클래스를 상속한 클래스들이 많은 공통 메소드들과 필드와 public 보다 다양한 접근 제어자에 의해 사용하고 싶을때.  
        non-static 과 non-final 필드를 선언하고 싶을때.  결과적으로 객체들의 상태를 메소드에서 접근하고 수정 할 수 있게 되겠지.  
    - 인터페이스
        크게 상관없는(is-a 정도는 아닌 has-a 정도인) 클래스들이 너의 인터페이스를 구현( java8 부터는 구현된 것을 사용도 포함)해야 할 필요가 있을때. 예를들어 Comparable and Cloneable  
        특정 데이터타입의 행위를 특별하게 구현하길 원할때 그러나 누가 그것의 행위를 구현 했는지에 대한 관심은 없을때  
        다중 구현상속의 이점을 누려야 할때  
    [출처](https://hamait.tistory.com/650)  

#### 4장 - 스트림 소개
- “효율적인 병렬화 조건을 잘 갖추었더라도, 파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못하면 성능 향상은 미미할 수 있다. 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱했을 때, 값이 최소 수십만은 되어야 성능 향상을 기대할 수 있다.”  [참고](https://demoversion.tistory.com/34)